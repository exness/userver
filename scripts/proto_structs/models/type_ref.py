"""Models for usages of C++ types."""

from __future__ import annotations

import abc
from collections.abc import Iterable
from collections.abc import Sequence
import dataclasses
import itertools

from typing_extensions import override

from proto_structs.models import includes
from proto_structs.models import names


class TypeReference(names.HasCppName, includes.HasCppIncludes, abc.ABC):
    """A usage of C++ type (not its definition)."""


@dataclasses.dataclass(frozen=True)
class TemplateType(TypeReference):
    """A usage of a compound template type, together with its template arguments."""

    #: The type template without args.
    template: TypeReference
    #: Entities passed as template parameter values. May be empty, `Foo<>` can be a valid 0-arg template instantiation.
    template_args: Sequence[TypeReference]

    @override
    def full_cpp_name(self) -> str:
        own_name = self.template.full_cpp_name()
        args = self.template_args
        return f'{own_name}<{", ".join(arg.full_cpp_name() for arg in args)}>'

    @override
    def contextual_cpp_name(self, *, context: names.HasCppName) -> str:
        own_name = self.template.contextual_cpp_name(context=context)
        args = self.template_args
        return f'{own_name}<{", ".join(arg.contextual_cpp_name(context=context) for arg in args)}>'

    @override
    def full_cpp_name_segments(self) -> Sequence[str]:
        # Example: `foo::Bar::Baz<A, B> -> ['foo', 'Bar', 'Baz<A, B>']
        template_name_segments = self.template.full_cpp_name_segments()
        assert template_name_segments
        args = self.template_args
        last_segment = f'{template_name_segments[-1]}<{", ".join(arg.full_cpp_name() for arg in args)}>'
        return *itertools.islice(template_name_segments, len(template_name_segments) - 1), last_segment

    @override
    def collect_includes(self) -> Iterable[str]:
        yield from self.template.collect_includes()
        for arg in self.template_args:
            yield from arg.collect_includes()


class KeywordType(TypeReference, names.HasCppName):
    """A C++ keyword that is represents a type."""

    def __init__(self, *, full_cpp_name: str) -> None:
        super().__init__()
        self._full_cpp_name = full_cpp_name

    @override
    def full_cpp_name(self) -> str:
        return self._full_cpp_name

    @override
    def contextual_cpp_name(self, *, context: names.HasCppName) -> str:
        return self._full_cpp_name

    @override
    def full_cpp_name_segments(self) -> Sequence[str]:
        return (self._full_cpp_name,)

    @override
    def collect_includes(self) -> Sequence[str]:
        return ()


class BuiltinType(TypeReference, names.HasCppNameImpl):
    """A usage of a non-code-generated C++ type."""

    def __init__(self, *, full_cpp_name: str, include: str) -> None:
        super().__init__()
        self._full_cpp_name = full_cpp_name
        self._include = include

    @override
    def full_cpp_name_segments(self) -> Sequence[str]:
        # Return a single segment so that `contextual_cpp_name(context) == full_cpp_name`.
        return (self._full_cpp_name,)

    @override
    def collect_includes(self) -> Iterable[str]:
        return [self._include]


class UserverCodegenType(TypeReference, names.HasCppNameImpl):
    """A usage of a C++ type generated by userver proto_structs plugin."""

    def __init__(self, *, name: names.TypeName, include: str) -> None:
        super().__init__()
        self._name = name
        self._include = include

    @override
    def full_cpp_name_segments(self) -> Sequence[str]:
        return self._name.name_segments()

    @override
    def collect_includes(self) -> Iterable[str]:
        return [self._include]
